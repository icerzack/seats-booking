#cloud-config
package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - containerd
  - apache2-utils

# Let iptables see bridged traffic
write_files:
  - path: /etc/modules-load.d/k8s.conf
    content: |
      br_netfilter
      overlay

  - path: /etc/sysctl.d/k8s.conf
    content: |
      net.bridge.bridge-nf-call-ip6tables = 1
      net.bridge.bridge-nf-call-iptables = 1
      net.ipv4.ip_forward = 1

  # Configure containerd
  - path: /etc/containerd/config.toml
    content: |
      version = 2
      
      [plugins]
        [plugins."io.containerd.grpc.v1.cri"]
          sandbox_image = "registry.k8s.io/pause:3.9"
          [plugins."io.containerd.grpc.v1.cri".containerd]
            [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
              [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
                runtime_type = "io.containerd.runc.v2"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
                  SystemdCgroup = true

  # k8s deployment
  - path: /root/install-k8s.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      # Логирование
      exec > >(tee -a /var/log/install-k8s.log) 2>&1
      
      echo "[$(date)] Starting Kubernetes installation"
      
      # Hostname resolution fix
      HOSTNAME=$(hostname)
      echo "127.0.0.1 $HOSTNAME" >> /etc/hosts
      
      # Restart containerd
      systemctl restart containerd
      sleep 5
      
      # Add Kubernetes repo and install
      curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
      echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /" > /etc/apt/sources.list.d/kubernetes.list
      apt-get update
      apt-get install -y kubelet kubeadm kubectl
      apt-mark hold kubelet kubeadm kubectl
      
      # Create env file to set KUBECONFIG for all users
      echo 'export KUBECONFIG=/etc/kubernetes/admin.conf' > /etc/profile.d/kubeconfig.sh
      chmod +x /etc/profile.d/kubeconfig.sh
      
      # Set KUBECONFIG for current session
      export KUBECONFIG=/etc/kubernetes/admin.conf
      
      # Init Kubernetes
      echo "[$(date)] Initializing Kubernetes cluster..."
      kubeadm init --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=all
      
      # Setup kubectl
      mkdir -p /root/.kube
      cp -i /etc/kubernetes/admin.conf /root/.kube/config
      
      # Export join command for convenience
      JOIN_COMMAND=$(kubeadm token create --print-join-command)
      echo "To join more nodes, use this command:" > /root/k8s-join-command.txt
      echo "$JOIN_COMMAND" >> /root/k8s-join-command.txt
      
      # Install Flannel
      echo "[$(date)] Installing Flannel network plugin..."
      kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
      
      # Wait for CoreDNS pods to be running
      echo "[$(date)] Waiting for CoreDNS to be ready..."
      kubectl -n kube-system wait --for=condition=ready pod --selector=k8s-app=kube-dns --timeout=180s || true
      
      # Allow pods on master
      echo "[$(date)] Removing taint from control-plane node..."
      kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true
      kubectl taint nodes --all node-role.kubernetes.io/master- || true
      
      echo "[$(date)] Kubernetes installation completed"
      echo "[$(date)] Cluster status:"
      kubectl get nodes

  # Application deployment
  - path: /root/deploy-app.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      # Логирование
      exec > >(tee -a /var/log/deploy-app.log) 2>&1
      
      echo "[$(date)] Deploying application"
      
      # Правильная настройка kubectl
      export KUBECONFIG=/etc/kubernetes/admin.conf
      
      # Дадим API серверу время полностью запуститься
      echo "[$(date)] Waiting for API server to be fully available..."
      for i in {1..30}; do
        if kubectl get nodes &>/dev/null; then
          echo "[$(date)] API server is ready"
          break
        fi
        echo "[$(date)] Waiting for API server... attempt $i/30"
        sleep 5
      done
      
      # Create k8s manifests
      mkdir -p /root/k8s
      
      # Create namespace
      cat > /root/k8s/namespace.yaml << 'EOL'
      apiVersion: v1
      kind: Namespace
      metadata:
        name: seats-booking
      EOL
      
      # Create ConfigMap for nginx configuration
      cat > /root/k8s/nginx-config.yaml << 'EOL'
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: nginx-config
        namespace: seats-booking
      data:
        nginx.conf: |
          server {
            listen 80;
            
            location / {
              root /usr/share/nginx/html;
              index index.html index.htm;
              try_files $uri $uri/ /index.html;
            }
            
            # API forwarding 
            location /api/ {
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_pass http://127.0.0.1:10101;
            }
          }
      EOL
      
      # Create deployment with proper ports and health probes
      cat > /root/k8s/app.yaml << 'EOL'
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: seats-booking
        namespace: seats-booking
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: seats-booking
        template:
          metadata:
            labels:
              app: seats-booking
          spec:
            containers:
            - name: seats-booking
              image: ghcr.io/icerzack/seats-booking:latest
              imagePullPolicy: Always
              ports:
              - containerPort: 80
                name: http
              readinessProbe:
                httpGet:
                  path: /
                  port: 80
                initialDelaySeconds: 10
                periodSeconds: 5
              livenessProbe:
                httpGet:
                  path: /
                  port: 80
                initialDelaySeconds: 20
                periodSeconds: 15
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: seats-booking-service
        namespace: seats-booking
      spec:
        selector:
          app: seats-booking
        ports:
        - port: 80
          targetPort: 80
          nodePort: 30080
          name: http
        type: NodePort
      EOL
      
      # Apply manifests
      echo "[$(date)] Creating namespace"
      kubectl apply -f /root/k8s/namespace.yaml
      
      echo "[$(date)] Applying nginx config"
      kubectl apply -f /root/k8s/nginx-config.yaml
      
      echo "[$(date)] Deploying application"
      kubectl apply -f /root/k8s/app.yaml
      
      # Wait for pod to be running
      echo "[$(date)] Waiting for application pod to be ready..."
      kubectl -n seats-booking wait --for=condition=ready pod --selector=app=seats-booking --timeout=300s || true
      
      # Get IP for info
      NODE_IP=$(hostname -I | awk '{print $1}')
      
      # Create workaround script for API routing issues
      cat > /root/fix-api-routing.sh << 'EOL'
      #!/bin/bash
      
      POD=$(kubectl -n seats-booking get pods -l app=seats-booking -o jsonpath='{.items[0].metadata.name}')
      
      echo "Creating custom nginx configuration to fix API routing"
      
      # Create temporary nginx configuration file
      cat > /tmp/nginx.conf << 'EOF'
      server {
        listen 80;
        
        location / {
          root /usr/share/nginx/html;
          try_files $uri $uri/ /index.html;
        }
        
        # API forwarding with corrected path
        location /api/v1/ {
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_pass http://127.0.0.1:8080/api/v1/;
        }
      }
      EOF
      
      # Copy nginx config to pod
      kubectl -n seats-booking cp /tmp/nginx.conf $POD:/etc/nginx/conf.d/default.conf
      
      # Reload nginx
      kubectl -n seats-booking exec $POD -- nginx -s reload
      
      echo "API routing fix applied, testing endpoint..."
      curl -v http://localhost:30080/api/v1/rooms?page=0&size=20
      
      echo "If you're still seeing issues, you may need to restart the pod:"
      echo "kubectl -n seats-booking rollout restart deployment seats-booking"
      EOL
      chmod +x /root/fix-api-routing.sh
      
      # Create debug script for troubleshooting
      cat > /root/debug-app.sh << 'EOL'
      #!/bin/bash
      
      # Get pod name
      POD=$(kubectl -n seats-booking get pods -l app=seats-booking -o jsonpath='{.items[0].metadata.name}')
      
      echo "---- Pod Status ----"
      kubectl -n seats-booking describe pod $POD
      
      echo "---- Pod Logs ----"
      kubectl -n seats-booking logs $POD
      
      echo "---- Service Details ----"
      kubectl -n seats-booking describe service seats-booking-service
      
      echo "---- Testing API Endpoint ----"
      curl -v http://localhost:30080/api/v1/rooms?page=0&size=20
      
      echo "---- Container Shell ----"
      echo "To access shell in container, run: kubectl -n seats-booking exec -it $POD -- /bin/sh"
      
      echo "---- Container Configuration ----"
      echo "Checking nginx configuration..."
      kubectl -n seats-booking exec $POD -- cat /etc/nginx/conf.d/default.conf || echo "No nginx config found"
      
      echo "---- Container Processes ----"
      kubectl -n seats-booking exec $POD -- ps aux || echo "Cannot list processes"
      
      echo "To fix API routing issues, run: /root/fix-api-routing.sh"
      EOL
      chmod +x /root/debug-app.sh
      
      # Create info file
      cat > /root/app-info.txt << EOL
      ========================================
      Seats Booking Application
      ========================================
      URL: http://$NODE_IP:30080
      
      API: http://$NODE_IP:30080/api/v1/rooms?page=0&size=20
      
      DEBUG COMMANDS:
      /root/debug-app.sh - показать диагностическую информацию
      /root/fix-api-routing.sh - исправить проблемы с маршрутизацией API
      
      RESTART APPLICATION:
      kubectl -n seats-booking rollout restart deployment seats-booking
      ========================================
      EOL
      
      # Test API endpoint
      echo "[$(date)] Testing application endpoint..."
      sleep 10
      curl -v http://localhost:30080/api/v1/rooms?page=0&size=20 || true
      
      # Get pod logs
      POD=$(kubectl -n seats-booking get pods -l app=seats-booking -o jsonpath='{.items[0].metadata.name}' 2>/dev/null) || true
      if [ -n "$POD" ]; then
        echo "[$(date)] Application pod logs:"
        kubectl -n seats-booking logs $POD || true
        
        # Check if API is working, if not try to apply fix
        if ! curl -s http://localhost:30080/api/v1/rooms?page=0&size=20 | grep -q .; then
          echo "[$(date)] API seems to be unavailable, applying fix..."
          /root/fix-api-routing.sh
        fi
      fi
      
      echo "[$(date)] Application deployed at http://$NODE_IP:30080"
      echo "[$(date)] Use /root/debug-app.sh for troubleshooting"
      echo "[$(date)] Use /root/fix-api-routing.sh to fix API routing issues"

runcmd:
  # System setup
  - sysctl --system
  - modprobe br_netfilter
  - modprobe overlay
  
  # Install K8s
  - /root/install-k8s.sh
  - sleep 60
  
  # Deploy application
  - /root/deploy-app.sh

final_message: "Kubernetes and application setup is complete. Check /root/app-info.txt for details." 